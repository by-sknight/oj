#include <iostream>
using namespace std;

int f(int m, int n) {
    if (m < 0 || n < 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    if (m == 1 || m == 0) {
        return 1;
    }
    return f(m, n - 1) + f(m - n, n);
}

int main() {
    int m, n;
    std::cin >> m >> n;
    std::cout << f(m, n) << std::endl;
}

// 不太熟悉，边缘条件按照自己的理解写的，思路参考 https://blog.nowcoder.net/n/67362f55cdb8467d900f2569899b9c4d
// m 个苹果放在 n 个盘子中，苹果和盘子都是相同的，允许盘子中什么都不放，问有多少种不同的分法
// 自己分析过程中，重点放在苹果上，最后没有分析出答案
// 参考博客的理解
//   设T(m,n)表示m个苹果放在n个盘子里的最大分法，如果有空盘，问题规模可以缩减为T(m,n-1)，不用关注具体空盘位置，这里的m,n没有任何顺序的关系，仅仅表示数量级别，也就是说，不用关注，为什么n这个位置是空盘
//       如果没有空盘，表示至少每个盘子上都有一个苹果，问题规模可以缩减为T(m-n,n)
//   对于实际每个T(m,n)计算的时候，有空盘和没有空盘是绝对对立的，不可能同时存在有空盘和没有空盘的情况
//       因此，就可以累加对应的值 T(m, n-1) T(m-n, n)
//       因为m-n没有加判断，所以条件放在边界条件中，如果m,n<0，不存在这种概念，返回0，如果n==1，表示一个盘子，只要m有效(>=0)，那么就只有一种情况，返回1。如果m==1或者m==0，不管盘子数量多少，最后的分布一定只有一种，1,0,0,0...或者全空，返回1
